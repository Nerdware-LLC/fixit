name: Deploy Workflow

on: { release: { types: [published] } }

# These permissions are needed to interact with GitHub's OIDC Token endpoint.
permissions: { id-token: write, contents: read }

jobs:
  push-to-ecr:
    name: Build, Tag, and Push Image to Amazon ECR
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: docker/setup-buildx-action@v3

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.ECR_OIDC_GITHUB_ROLE_ARN }}
          aws-region: ${{ secrets.ECR_REPO_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: "true"
          # Note: The above makes "outputs.registry" unavailable in any subsequent jobs.

      - name: Prepare Image Metadata
        id: image-meta
        run: |
          # ENV-DEPENDENT VALUES:
          if [ ${{ github.event.release.prerelease }} = true ]; then
              ENV_TAG=staging
              REL_POINTER_TAG=next
              TASK_DEF_NAME=${{ secrets.ECS_API_TASK_DEF_STAGING }}
              SERVICE_NAME=${{ secrets.ECS_API_SERVICE_NAME_STAGING }}
              CLUSTER_NAME=${{ secrets.ECS_CLUSTER_NAME_STAGING }}
          else
              ENV_TAG=prod
              REL_POINTER_TAG=latest
              TASK_DEF_NAME=${{ secrets.ECS_API_TASK_DEF_PROD }}
              SERVICE_NAME=${{ secrets.ECS_API_SERVICE_NAME_PROD }}
              CLUSTER_NAME=${{ secrets.ECS_CLUSTER_NAME_PROD }}
          fi

          BASE_URI="${{ steps.login-ecr.outputs.registry }}/${{ secrets.ECR_PRIVATE_REPO }}"

          for gh_output_kv_pair in \
              "base-uri=$BASE_URI" \
              "sha-tag-uri=$BASE_URI:${{ github.sha }}" \
              "env-tag-uri=$BASE_URI:$ENV_TAG" \
              "rel-pointer-tag-uri=$BASE_URI:$REL_POINTER_TAG" \
              "release-tag-uri=$BASE_URI:${{ github.event.release.tag_name }}" \
              "task-def-name=$TASK_DEF_NAME" \
              "service-name=$SERVICE_NAME" \
              "cluster-name=$CLUSTER_NAME"; do

              echo "$gh_output_kv_pair" >> "$GITHUB_OUTPUT"
          done

      - name: Build and Push Image+Tags
        run: |
          IMAGE_TAGS=(
              ${{ steps.image-meta.outputs.sha-tag-uri }}
              ${{ steps.image-meta.outputs.env-tag-uri }}
              ${{ steps.image-meta.outputs.rel-pointer-tag-uri }}
              ${{ steps.image-meta.outputs.release-tag-uri }}
          )

          docker build ${IMAGE_TAGS[@]/#/--tag } .

          for tag in "${IMAGE_TAGS[@]}"; do docker push "$tag"; done

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.ECS_OIDC_GITHUB_ROLE_ARN }}
          aws-region: ${{ secrets.ECS_CLUSTER_REGION }}

      - name: Update ECS Task Definition & Service
        run: |
          UPDATED_TASK_DEF_JSON=$(
              aws ecs describe-task-definition \
                  --task-definition ${{ steps.image-meta.outputs.task-def-name }} \
                  --output json | \
                  jq --arg NEW_IMAGE ${{ steps.image-meta.outputs.sha-tag-uri }} \
                      '.taskDefinition |
                      .containerDefinitions[0].image = $NEW_IMAGE |
                      del(.taskDefinitionArn) |
                      del(.revision) |
                      del(.status) |
                      del(.requiresAttributes) |
                      del(.compatibilities) |
                      del(.registeredAt) |
                      del(.registeredBy)'
          )

          aws ecs register-task-definition \
              --cli-input-json "$UPDATED_TASK_DEF_JSON"

          aws ecs update-service \
              --cluster ${{ steps.image-meta.outputs.cluster-name }} \
              --service ${{ steps.image-meta.outputs.service-name }} \
              --task-definition ${{ steps.image-meta.outputs.task-def-name }} \
              --force-new-deployment
